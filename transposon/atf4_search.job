#!/bin/bash --login
#$ -cwd
#$ -t 1-218
#$ -N zatf4
module load apps/binapps/anaconda3/2020.07
module load tools/env/proxy2 


FOLDER=`awk "NR==$SGE_TASK_ID" folder_paths.txt`

# Enter the isolate folder
cd $FOLDER
# Extract prefix
PREFIX=$(echo $FOLDER | rev | cut -d"/" -f1 | rev)
GENOME=./megahit*/$PREFIX.contigs.fa


# 1) PERFORM ALIGNMENTS
conda activate blast_env
makeblastdb -in $GENOME -dbtype nucl -out genome_db
# Search the ORF against the genome
blastn -db genome_db -query /mnt/iusers01/pb01/f99731hc/scratch/imperial/orf.fasta -out orf_plus -outfmt 6 -strand plus -evalue 0.01
blastn -db genome_db -query /mnt/iusers01/pb01/f99731hc/scratch/imperial/orf.fasta -out orf_minus -outfmt 6 -strand minus -evalue 0.01
# Search TIR against genome
blastn -db genome_db -query /mnt/iusers01/pb01/f99731hc/scratch/imperial/tir.fasta -out tir_plus -outfmt 6 -strand plus -evalue 0.01
blastn -db genome_db -query /mnt/iusers01/pb01/f99731hc/scratch/imperial/tir.fasta -out tir_minus -outfmt 6 -strand minus -evalue 0.01


# 2) GENERATE BEDFILES FROM BLAST OUTPUT
conda activate bedtools_env
rm *.bed *.summary *.fasta
grep -v '^#' orf_plus| perl -ane 'if($F[8]<=$F[9]){print join("\t",$F[1],$F[8]-1,$F[9],$F[0],"0","+"),"\n";}else{print join("\t",$F[1],$F[9]-1,$F[8],$F[0],"0","-"),"\n";}' | sort >> orf_plus.tmp.bed
grep -v '^#' orf_minus| perl -ane 'if($F[8]<=$F[9]){print join("\t",$F[1],$F[8]-1,$F[9],$F[0],"0","+"),"\n";}else{print join("\t",$F[1],$F[9]-1,$F[8],$F[0],"0","-"),"\n";}' | sort >> orf_minus.tmp.bed
grep -v '^#' tir_plus| perl -ane 'if($F[8]<=$F[9]){print join("\t",$F[1],$F[8]-1,$F[9],$F[0],"0","+"),"\n";}else{print join("\t",$F[1],$F[9]-1,$F[8],$F[0],"0","-"),"\n";}' | sort >> tir_plus.bed
grep -v '^#' tir_minus| perl -ane 'if($F[8]<=$F[9]){print join("\t",$F[1],$F[8]-1,$F[9],$F[0],"0","+"),"\n";}else{print join("\t",$F[1],$F[9]-1,$F[8],$F[0],"0","-"),"\n";}' | sort >> tir_minus.bed

while read line
do
newname=$(echo $line | cut -d" " -f1-3 | sed "s/ /_/g")
echo "$line" | sed "s/atf4_orf/$newname/" >> orf_plus.bed
done <orf_plus.tmp.bed

while read line
do
newname=$(echo $line | cut -d" " -f1-3 | sed "s/ /_/g")
echo "$line" | sed "s/atf4_orf/$newname/" >> orf_minus.bed
done <orf_minus.tmp.bed
# Add ORF identifier for downstream analysis


# 3) COUNT NUMBER OF TRUE UNIQUE ITR
bedtools intersect -wo -a tir_plus.bed -b tir_minus.bed > tir_overlap.tsv
bedtools intersect -v -wo -a tir_plus.bed -b tir_minus.bed > tir_plus_unique.tsv
bedtools intersect -v -wo -a tir_minus.bed -b tir_plus.bed > tir_minus_unique.tsv
### DATA ###
tir_total=$(cat tir_overlap.tsv tir_plus_unique.tsv tir_minus_unique.tsv | wc -l)
tir_partial=$(cat tir_plus_unique.tsv tir_minus_unique.tsv | wc -l)
tir_full=$(cat tir_overlap.tsv | wc -l)
############
# Store full TIRs
cat tir_overlap.tsv | cut -d$'\t' -f1-6 > full_tir_plus.bed
cat tir_overlap.tsv | cut -d$'\t' -f7-12 > full_tir_minus.bed

# 4) COUNT THE NUMBER OF ORF OVERLAPS
### DATA ###
orf_total=$(cat orf_plus.bed orf_minus.bed | wc -l)
############

# 5) IDENTIFY TIRs FLANKING EACH OTHER
# NOTE: FOR PLUS STRAND START-->END, FOR MINUS STRAND END<--START BUT THE VALUES ARE IN THE CORRECT ORDER
grep TIR_start full_tir_plus.bed > tir_start_plus.bed
grep TIR_end full_tir_plus.bed > tir_end_plus.bed
bedtools closest -io -s -iu -D a -a tir_start_plus.bed -b tir_end_plus.bed > tmp.closest.txt
awk '$13<10000' tmp.closest.txt | awk '$13>0'> tir_tir_plus.closest.txt
 

grep TIR_start full_tir_minus.bed > tir_start_minus.bed
grep TIR_end full_tir_minus.bed > tir_end_minus.bed
bedtools closest -io -s -iu -D b -a tir_end_minus.bed -b tir_start_minus.bed > tmp.closest.txt
awk '$13<10000' tmp.closest.txt | awk '$13>0' > tir_tir_minus.closest.txt

# Convert these flanks into a locus 
while read line
do
	chr=$(echo "$line" | cut -d$'\t' -f1)
	start=$(echo "$line" | cut -d$'\t' -f3)
	stop=$(echo "$line" | cut -d$'\t' -f8)
	name="${chr}_${start}_${stop}"
	echo -e "$chr\t$start\t$stop\t$name\t0\t+" >> tir_tir_plus_flank.bed
done <tir_tir_plus.closest.txt

while read line
do
	chr=$(echo "$line" | cut -d$'\t' -f1)
	start=$(echo "$line" | cut -d$'\t' -f3)
	stop=$(echo "$line" | cut -d$'\t' -f8)
	name="${chr}_${start}_${stop}"
	echo -e "$chr\t$start\t$stop\t$name\t0\t-" >> tir_tir_minus_flank.bed
done <tir_tir_minus.closest.txt
# Count the number of TIRs next to each other within 10kb
### DATA ###
tir_flank_total=$(cat tir_tir_plus_flank.bed | wc -l)
############

# 6) IDENTIFY IF ANY ORFs ARE IN BETWEEN TIRs
bedtools intersect -wo -a tir_tir_plus_flank.bed -b orf_plus.bed > tir_orf_tir_plus.tsv
while read line
do
	chr=$(echo "$line" | cut -d$'\t' -f7)
	startloc=$(echo "$line" | cut -d$'\t' -f2)
	stoploc=$(echo "$line" | cut -d$'\t' -f3)
	nameloc="${chr}_${startloc}_${stoploc}"
	echo -e "$chr\t$startloc\t$stoploc\t$nameloc\t0\t+" >> tir_orf_tir_plus.loc.bed

	chr=$(echo "$line" | cut -d$'\t' -f7)
	startorf=$(echo "$line" | cut -d$'\t' -f8)
	stoporf=$(echo "$line" | cut -d$'\t' -f9)
	nameorf="${chr}_${startorf}_${stoporf}"
	echo -e "$chr\t$startorf\t$stoporf\t$nameorf\t0\t+" >> tir_orf_tir_plus.orf.bed
done <tir_orf_tir_plus.tsv



bedtools intersect -wo -a tir_tir_minus_flank.bed -b orf_minus.bed > tir_orf_tir_minus.tsv
while read line
do
	chr=$(echo "$line" | cut -d$'\t' -f7)
	startloc=$(echo "$line" | cut -d$'\t' -f2)
	stoploc=$(echo "$line" | cut -d$'\t' -f3)
	nameloc="${chr}_${startloc}_${stoploc}"
	echo -e "$chr\t$startloc\t$stoploc\t$nameloc\t0\t-" >> tir_orf_tir_minus.loc.bed

	chr=$(echo "$line" | cut -d$'\t' -f7)
	startorf=$(echo "$line" | cut -d$'\t' -f8)
	stoporf=$(echo "$line" | cut -d$'\t' -f9)
	nameorf="${chr}_${startorf}_${stoporf}"
	echo -e "$chr\t$startorf\t$stoporf\t$nameorf\t0\t-" >> tir_orf_tir_minus.orf.bed
done <tir_orf_tir_minus.tsv

cat tir_orf_tir_plus.orf.bed tir_orf_tir_minus.orf.bed > tir_orf_tir.orf.bed
cat tir_orf_tir_plus.loc.bed tir_orf_tir_minus.loc.bed > tir_orf_tir.loc.bed
### DATA ###
tir_orf_tir_total=$(cat tir_orf_tir.orf.bed| wc -l)
############

# 7) EXTRACT tORFs with NO FLANKS
# Check that the tORF isn't in a flank position

if [[ -e orf_plus.bed ]]
then
	if [[ -e tir_orf_tir.loc.bed ]]
	then
		bedtools intersect -v -a orf_plus.bed -b  tir_orf_tir.loc.bed > orf_noflank_plus.orf.bed
	else
		cat orf_plus.bed > orf_noflank_plus.orf.bed
	fi
fi	

if [[ -e orf_minus.bed ]]
then
	if [[ -e tir_orf_tir.loc.bed ]]
	then
		bedtools intersect -v -a orf_minus.bed -b  tir_orf_tir.loc.bed > orf_noflank_minus.orf.bed
	else
		cat orf_minus.bed > orf_noflank_minus.orf.bed
	fi
fi	
	


cat orf_noflank_plus.orf.bed orf_noflank_minus.orf.bed > orf_noflank_total.bed
### DATA ###
orf_no_flank_total=$(cat orf_noflank_total.bed | wc -l)
############


# 8) EXTRACT FLANKS WITH NO tORF (nuorf)



if [[ -e tir_orf_tir.loc.bed ]]
then
	bedtools intersect -v -a tir_tir_plus_flank.bed -b tir_orf_tir.loc.bed >tir_possorf_tir_plus.loc.bed
	bedtools intersect -v -a tir_tir_minus_flank.bed -b tir_orf_tir.loc.bed >tir_possorf_tir_minus.loc.bed
else
	cat tir_tir_plus_flank.bed > orf_noflank_plus.orf.bed
	cat tir_tir_minus_flank.bed > orf_noflank_minus.orf.bed
fi


# Check for unique flanks i.e if the same flank is found on the plus/minus strand exclude this from being "unique"
cat tir_possorf_tir_plus.loc.bed tir_possorf_tir_minus.loc.bed > tir_possorf_tir_all.loc.bed
sed 's/+/-/g' tir_possorf_tir_all.loc.bed | sort | uniq > unique.tir_possorf_tir_all.loc.bed

# Check ORFs within each section
while read line
do
	echo "$line" > tmp.bed
	conda activate bedtools_env
	bedtools getfasta -s -fi $GENOME -fo tmp.fa -bed tmp.bed
	# Extract nuorf sequences and check for ORFs
	conda activate emboss_env
	getorf -min 90 tmp.fa orf.tmp.fa
	if [ $(grep ">" orf.tmp.fa | wc -l) -gt 0 ] 
	then
	# BED with unique TIR-ORF-TIR
		echo "$line" >> tir_uorf_tir_plus.loc.bed
	else
	# BED with NO unique TIR-ORF-TIR
		echo "$line" >> tir_nuorf_tir_plus.loc.bed
	fi
done <tir_possorf_tir_plus.loc.bed

while read line
do
	echo "$line" > tmp.bed
	conda activate bedtools_env
	bedtools getfasta -s -fi $GENOME -fo tmp.fa -bed tmp.bed
	# Extract nuorf sequences and check for ORFs
	conda activate emboss_env
	getorf -min 90 tmp.fa orf.tmp.fa
	if [ $(grep ">" orf.tmp.fa | wc -l) -gt 0 ] 
	then
	# BED with unique TIR-ORF-TIR
		echo "$line" >> tir_uorf_tir_minus.loc.bed
	else
	# BED with NO unique TIR-ORF-TIR
		echo "$line" >> tir_nuorf_tir_minus.loc.bed
	fi
done <tir_possorf_tir_minus.loc.bed

# Extract sequences which have an ORF on either or both strands
cat tir_uorf_tir_minus.loc.bed tir_uorf_tir_plus.loc.bed > tir_uorf_tir_all.loc.bed
awk '{ print $4 }' tir_uorf_tir_all.loc.bed | sort | uniq -c > tir_uorf_tir_all.loc.counts
urof_flank_single_dir=$(awk '$1<2' tir_uorf_tir_all.loc.counts | wc -l)
urof_flank_multi_dir=$(awk '$1>1' tir_uorf_tir_all.loc.counts | wc -l)


# Extract sequences which do not have an ORF on a single strand (min.)
cat tir_nuorf_tir_minus.loc.bed tir_nuorf_tir_plus.loc.bed | awk '{ print $4 }' | sort | uniq -c > tir_nuorf_tir_all.loc.counts


### DATA ###
# Flanking TIRs without our original tORF
possorf_flank_total=$(cat unique.tir_possorf_tir_all.loc.bed | wc -l)
possorf_flank_plus_total=$(cat tir_possorf_tir_plus.loc.bed | wc -l)
possorf_flank_minus_total=$(cat tir_possorf_tir_minus.loc.bed | wc -l)
# Flanking TIRs with a unique ORF
uorf_flank_total=$(cat tir_uorf_tir_all.loc.counts | wc -l)
# Flanking TIRs with NO ORF
nuorf_flank_total=$(cat tir_nuorf_tir_all.loc.counts | wc -l)
############


# 9) SAVE ALL OF THE SEQUENCE INFO
conda activate bedtools_env
# ORF/loci with flanks
bedtools getfasta -s -fo tir_orf_tir.orf.fa -fi $GENOME -bed tir_orf_tir.orf.bed
bedtools getfasta -s -fo tir_orf_tir.loc.fa -fi $GENOME -bed tir_orf_tir.loc.bed
# ORF with no flanks
bedtools getfasta -s -fo orf_no_tir.orf.fa -fi $GENOME -bed orf_noflank_total.bed
# Flanks with new ORF
bedtools getfasta -s -fo tir_unknownorf_tir.all.loc.fa -fi $GENOME -bed tir_uorf_tir_all.loc.bed


sed -i "s/>/>${PREFIX}_/g" tir_orf_tir.orf.fa
sed -i "s/>/>${PREFIX}_/g"tir_orf_tir.loc.fa
sed -i "s/>/>${PREFIX}_/g" orf_no_tir.orf.fa
sed -i "s/>/>${PREFIX}_/g" tir_unknownorf_tir.all.loc.fa


# 10) SAVE ALL THE DESCRIPTION INFO
echo "${PREFIX},${tir_total},${tir_full},${tir_partial},${orf_total},${tir_flank_total},${tir_orf_tir_total},${orf_no_flank_total},${possorf_flank_total},${uorf_flank_total},${urof_flank_single_dir},${urof_flank_multi_dir},${nuorf_flank_total}" > atf4.summary

