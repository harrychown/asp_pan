#!/bin/bash --login
#$ -cwd
#$ -t 1-218
#$ -N zatf4
module load apps/binapps/anaconda3/2020.07
module load tools/env/proxy2 


FOLDER=`awk "NR==$SGE_TASK_ID" folder_paths.txt`

# Enter the isolate folder
cd $FOLDER
# Extract prefix
PREFIX=$(echo $FOLDER | rev | cut -d"/" -f1 | rev)
GENOME=./megahit*/$PREFIX.contigs.fa


# 1) PERFORM ALIGNMENTS
conda activate blast_env
makeblastdb -in $GENOME -dbtype nucl -out genome_db
# Search the ORF against the genome
blastn -db genome_db -query /mnt/iusers01/pb01/f99731hc/scratch/imperial/orf.fasta -out orf_plus -outfmt 6 -strand plus -evalue 0.01
blastn -db genome_db -query /mnt/iusers01/pb01/f99731hc/scratch/imperial/orf.fasta -out orf_minus -outfmt 6 -strand minus -evalue 0.01
# Search TIR against genome
blastn -db genome_db -query /mnt/iusers01/pb01/f99731hc/scratch/imperial/tir.fasta -out tir_plus -outfmt 6 -strand plus -evalue 0.01
blastn -db genome_db -query /mnt/iusers01/pb01/f99731hc/scratch/imperial/tir.fasta -out tir_minus -outfmt 6 -strand minus -evalue 0.01

# 2) GENERATE BEDFILES FROM BLAST OUTPUT
conda activate bedtools_env
rm *.bed *.summary *.fasta *.loc.counts
grep -v '^#' orf_plus| perl -ane 'if($F[8]<=$F[9]){print join("\t",$F[1],$F[8]-1,$F[9],$F[0],"0","+"),"\n";}else{print join("\t",$F[1],$F[9]-1,$F[8],$F[0],"0","-"),"\n";}' | sort >> orf_plus.tmp.bed
grep -v '^#' orf_minus| perl -ane 'if($F[8]<=$F[9]){print join("\t",$F[1],$F[8]-1,$F[9],$F[0],"0","+"),"\n";}else{print join("\t",$F[1],$F[9]-1,$F[8],$F[0],"0","-"),"\n";}' | sort >> orf_minus.tmp.bed
grep -v '^#' tir_plus| perl -ane 'if($F[8]<=$F[9]){print join("\t",$F[1],$F[8]-1,$F[9],$F[0],"0","+"),"\n";}else{print join("\t",$F[1],$F[9]-1,$F[8],$F[0],"0","-"),"\n";}' | sort >> tir_plus.bed
grep -v '^#' tir_minus| perl -ane 'if($F[8]<=$F[9]){print join("\t",$F[1],$F[8]-1,$F[9],$F[0],"0","+"),"\n";}else{print join("\t",$F[1],$F[9]-1,$F[8],$F[0],"0","-"),"\n";}' | sort >> tir_minus.bed


while read line
do
newname=$(echo $line | cut -d" " -f1-3 | sed "s/ /_/g")
echo "$line" | sed "s/atf4_orf/$newname/" >> orf_plus.bed
done <orf_plus.tmp.bed

while read line
do
newname=$(echo $line | cut -d" " -f1-3 | sed "s/ /_/g")
echo "$line" | sed "s/atf4_orf/$newname/" >> orf_minus.bed
done <orf_minus.tmp.bed
# Add ORF identifier for downstream analysis


# 3) COUNT NUMBER OF TRUE UNIQUE ITR
bedtools intersect -wo -a tir_plus.bed -b tir_minus.bed > tir_overlap.tsv
bedtools intersect -v -wo -a tir_plus.bed -b tir_minus.bed > tir_plus_unique.tsv
bedtools intersect -v -wo -a tir_minus.bed -b tir_plus.bed > tir_minus_unique.tsv
### DATA ###
tir_total=$(cat tir_overlap.tsv tir_plus_unique.tsv tir_minus_unique.tsv | wc -l)
tir_partial=$(cat tir_plus_unique.tsv tir_minus_unique.tsv | wc -l)
tir_full=$(cat tir_overlap.tsv | wc -l)
############
# Store full TIRs
cat tir_overlap.tsv | cut -d$'\t' -f1-6 > full_tir_plus.bed
cat tir_overlap.tsv | cut -d$'\t' -f7-12 > full_tir_minus.bed

# 4) COUNT THE NUMBER OF ORF OVERLAPS
### DATA ###
orf_total=$(cat orf_plus.bed orf_minus.bed | wc -l)
############

# 5) IDENTIFY TIRs FLANKING EACH OTHER
# NOTE: FOR PLUS STRAND START-->END, FOR MINUS STRAND END<--START BUT THE VALUES ARE IN THE CORRECT ORDER
grep TIR_start full_tir_plus.bed > tir_start_plus.bed
grep TIR_end full_tir_plus.bed > tir_end_plus.bed
bedtools closest -io -s -iu -D a -a tir_start_plus.bed -b tir_end_plus.bed > tmp.closest.txt
awk '$13<10000' tmp.closest.txt | awk '$13>0'> tir_tir_plus.closest.txt
 

grep TIR_start full_tir_minus.bed > tir_start_minus.bed
grep TIR_end full_tir_minus.bed > tir_end_minus.bed
bedtools closest -io -s -iu -D b -a tir_end_minus.bed -b tir_start_minus.bed > tmp.closest.txt
awk '$13<10000' tmp.closest.txt | awk '$13>0' > tir_tir_minus.closest.txt

# Convert these flanks into a locus 
while read line
do
	chr=$(echo "$line" | cut -d$'\t' -f1)
	start=$(echo "$line" | cut -d$'\t' -f3)
	stop=$(echo "$line" | cut -d$'\t' -f8)
	name="${chr}_${start}_${stop}"
	echo -e "$chr\t$start\t$stop\t$name\t0\t+" >> tir_tir_plus_flank.bed
done <tir_tir_plus.closest.txt

while read line
do
	chr=$(echo "$line" | cut -d$'\t' -f1)
	start=$(echo "$line" | cut -d$'\t' -f3)
	stop=$(echo "$line" | cut -d$'\t' -f8)
	name="${chr}_${start}_${stop}"
	echo -e "$chr\t$start\t$stop\t$name\t0\t-" >> tir_tir_minus_flank.bed
done <tir_tir_minus.closest.txt
# Count the number of TIRs next to each other within 10kb
### DATA ###
tir_flank_total=$(cat tir_tir_plus_flank.bed | wc -l)
############

# 6) IDENTIFY IF ANY ORFs ARE IN BETWEEN TIRs
bedtools intersect -wo -a tir_tir_plus_flank.bed -b orf_plus.bed > tir_orf_tir_plus.tsv
while read line
do
	chr=$(echo "$line" | cut -d$'\t' -f7)
	startloc=$(echo "$line" | cut -d$'\t' -f2)
	stoploc=$(echo "$line" | cut -d$'\t' -f3)
	nameloc="${chr}_${startloc}_${stoploc}"
	echo -e "$chr\t$startloc\t$stoploc\t$nameloc\t0\t+" >> tir_orf_tir_plus.loc.bed

	chr=$(echo "$line" | cut -d$'\t' -f7)
	startorf=$(echo "$line" | cut -d$'\t' -f8)
	stoporf=$(echo "$line" | cut -d$'\t' -f9)
	nameorf="${chr}_${startorf}_${stoporf}"
	echo -e "$chr\t$startorf\t$stoporf\t$nameorf\t0\t+" >> tir_orf_tir_plus.orf.bed
done <tir_orf_tir_plus.tsv



bedtools intersect -wo -a tir_tir_minus_flank.bed -b orf_minus.bed > tir_orf_tir_minus.tsv
while read line
do
	chr=$(echo "$line" | cut -d$'\t' -f7)
	startloc=$(echo "$line" | cut -d$'\t' -f2)
	stoploc=$(echo "$line" | cut -d$'\t' -f3)
	nameloc="${chr}_${startloc}_${stoploc}"
	echo -e "$chr\t$startloc\t$stoploc\t$nameloc\t0\t-" >> tir_orf_tir_minus.loc.bed

	chr=$(echo "$line" | cut -d$'\t' -f7)
	startorf=$(echo "$line" | cut -d$'\t' -f8)
	stoporf=$(echo "$line" | cut -d$'\t' -f9)
	nameorf="${chr}_${startorf}_${stoporf}"
	echo -e "$chr\t$startorf\t$stoporf\t$nameorf\t0\t-" >> tir_orf_tir_minus.orf.bed
done <tir_orf_tir_minus.tsv

cat tir_orf_tir_plus.orf.bed tir_orf_tir_minus.orf.bed > tir_orf_tir.orf.bed
cat tir_orf_tir_plus.loc.bed tir_orf_tir_minus.loc.bed > tir_orf_tir.loc.bed
### DATA ###
tir_orf_tir_total=$(cat tir_orf_tir.orf.bed| wc -l)
############

# 7) EXTRACT tORFs with NO FLANKS
# Check that the tORF isn't in a flank position

if [[ -e orf_plus.bed ]]
then
	if [[ -e tir_orf_tir.loc.bed ]]
	then
		bedtools intersect -v -a orf_plus.bed -b  tir_orf_tir.loc.bed > orf_noflank_plus.orf.bed
	else
		cat orf_plus.bed > orf_noflank_plus.orf.bed
	fi
fi	

if [[ -e orf_minus.bed ]]
then
	if [[ -e tir_orf_tir.loc.bed ]]
	then
		bedtools intersect -v -a orf_minus.bed -b  tir_orf_tir.loc.bed > orf_noflank_minus.orf.bed
	else
		cat orf_minus.bed > orf_noflank_minus.orf.bed
	fi
fi	
	


cat orf_noflank_plus.orf.bed orf_noflank_minus.orf.bed > orf_noflank_total.bed
### DATA ###
orf_no_flank_total=$(cat orf_noflank_total.bed | wc -l)
############


# 8) EXTRACT FLANKS WITH NO tORF (nuorf)



if [[ -e tir_orf_tir.loc.bed ]]
then
	bedtools intersect -v -a tir_tir_plus_flank.bed -b tir_orf_tir.loc.bed >tir_possorf_tir_plus.loc.bed
	bedtools intersect -v -a tir_tir_minus_flank.bed -b tir_orf_tir.loc.bed >tir_possorf_tir_minus.loc.bed
else
	cat tir_tir_plus_flank.bed > orf_noflank_plus.orf.bed
	cat tir_tir_minus_flank.bed > orf_noflank_minus.orf.bed
fi


# Check for unique flanks i.e if the same flank is found on the plus/minus strand exclude this from being "unique"
cat tir_possorf_tir_plus.loc.bed tir_possorf_tir_minus.loc.bed > tir_possorf_tir_all.loc.bed
sed 's/+/-/g' tir_possorf_tir_all.loc.bed | sort | uniq > unique.tir_possorf_tir_all.loc.bed

# Check ORFs within each section
while read line
do
	echo "$line" > tmp.bed
	conda activate bedtools_env
	bedtools getfasta -s -fi $GENOME -fo tmp.fa -bed tmp.bed
	# Extract nuorf sequences and check for ORFs
	conda activate emboss_env
	getorf -min 280 -reverse N -find 1 tmp.fa orf.tmp.fa
	if [ $(grep ">" orf.tmp.fa | wc -l) -gt 0 ] 
	then
	# BED with unique TIR-ORF-TIR
		echo "$line" >> tir_uorf_tir_plus.loc.bed
	else
	# BED with NO unique TIR-ORF-TIR
		echo "$line" >> tir_nuorf_tir_plus.loc.bed
	fi
done <tir_possorf_tir_plus.loc.bed

while read line
do
	echo "$line" > tmp.bed
	conda activate bedtools_env
	bedtools getfasta -s -fi $GENOME -fo tmp.fa -bed tmp.bed
	# Extract nuorf sequences and check for ORFs
	conda activate emboss_env
	getorf -min 280 -reverse N -find 1 tmp.fa orf.tmp.fa
	if [ $(grep ">" orf.tmp.fa | wc -l) -gt 0 ] 
	then
	# BED with unique TIR-ORF-TIR
		echo "$line" >> tir_uorf_tir_minus.loc.bed
	else
	# BED with NO unique TIR-ORF-TIR
		echo "$line" >> tir_nuorf_tir_minus.loc.bed
	fi
done <tir_possorf_tir_minus.loc.bed

# Extract sequences which have an ORF on either or both strands
cat tir_uorf_tir_minus.loc.bed tir_uorf_tir_plus.loc.bed > tir_uorf_tir_all.loc.bed
awk '{ print $4 }' tir_uorf_tir_all.loc.bed | sort | uniq -c > tir_uorf_tir_all.loc.counts
urof_flank_single_dir=$(awk '$1<2' tir_uorf_tir_all.loc.counts | wc -l)
urof_flank_multi_dir=$(awk '$1>1' tir_uorf_tir_all.loc.counts | wc -l)


# Extract sequences which do not have an ORF on a single strand (min.)
cat tir_nuorf_tir_minus.loc.bed tir_nuorf_tir_plus.loc.bed | awk '{ print $4 }' | sort | uniq -c > tir_nuorf_tir_all.loc.counts


### DATA ###
# Flanking TIRs without our original tORF
possorf_flank_total=$(cat unique.tir_possorf_tir_all.loc.bed | wc -l)
possorf_flank_plus_total=$(cat tir_possorf_tir_plus.loc.bed | wc -l)
possorf_flank_minus_total=$(cat tir_possorf_tir_minus.loc.bed | wc -l)
# Flanking TIRs with a unique ORF
uorf_flank_total=$(cat tir_uorf_tir_all.loc.counts | wc -l)
# Flanking TIRs with NO ORF
nuorf_flank_total=$(cat tir_nuorf_tir_all.loc.counts | wc -l)
############


# 9) EXTRACT 100BP +/- TIR FLANKS
awk '{$2-=100;$3+=100}1' OFS='\t' tir_orf_tir.loc.bed > tir_orf_tir.flank.bed
awk '{$2-=100;$3=$2+100}1' OFS='\t' tir_orf_tir.loc.bed > start.flank.bed
awk '{$2=$3;$3=$2+100}1' OFS='\t' tir_orf_tir.loc.bed > end.flank.bed


# 10) IDENTIFY SYNTENY OF FLANKING GENES
# Convert gene GTF to bed file
conda activate bedops_env
gtf2bed < gene.gtf > gene.bed
# Identify anything within 700bp upstream and downstream
# Check against pan-genome and save centroid ID
while read line
do
	conda activate bedtools_env
	# UP'n'DOWN
	echo "$line" > tmp.closest.txt
	upstream_gene_id=$(bedtools closest -io -s -id -D a -a tmp.closest.txt -b gene.bed  | awk '$20<0' | cut -d$'\t' -f10)
	downstream_gene_id=$(bedtools closest -io -s -iu -D a -a tmp.closest.txt -b gene.bed | awk '$20>0' | cut -d$'\t' -f10) 
	
	# Extract fasta and perform pairwise comparison against putative ORF
	bedtools getfasta -s -fo tmp.fa -fi $GENOME -bed tmp.closest.txt
	conda activate emboss_env
	/mnt/iusers01/pb01/f99731hc/scratch/imperial/origin_atf4.fa
	
	# Pangenome search
	if [ ! -z "$upstream_gene_id" ]
	then
		up_num=$(grep -F "${upstream_gene_id}" /mnt/iusers01/pb01/f99731hc/scratch/imperial/matchtable.txt | cut -d$'\t' -f1)
		up_name=$(echo centroid_$up_num)
	else
		up_name=$(echo NA)
	fi


	if [ ! -z "$downstream_gene_id" ]
	then
		down_num=$(grep -F "${downstream_gene_id}" /mnt/iusers01/pb01/f99731hc/scratch/imperial/matchtable.txt | cut -d$'\t' -f1)
		down_name=$(echo centroid_$down_num)
	else
		down_name=$(echo NA)
	fi
	# Save result
	echo "${PREFIX},${up_name},${down_name}" >> synteny.summary
	
	if [ $up_name == "centroid_382" ] && [ $down_name == "centroid_383" ]
	then
		echo "$line" >> synt38x.bed
	elif [ $up_name == "centroid_9690" ] && [ $down_name == "centroid_9692" ]
	then
		echo "$line" >> synt969x.bed
	else
		echo "$line" >> syntUx.bed
	fi
	
done <tir_orf_tir.orf.bed
#### DATA ####
synt38total=$(cat synt38x.bed | wc -l)
synt969total=$(cat synt969x.bed | wc -l)
syntUtotal=$(cat syntUx.bed | wc -l)
##############

# 9) SAVE ALL OF THE SEQUENCE INFO
conda activate bedtools_env
# ORF/loci with flanks
bedtools getfasta -s -fo tir_orf_tir.orf.fa -fi $GENOME -bed tir_orf_tir.orf.bed
bedtools getfasta -s -fo tir_orf_tir.loc.fa -fi $GENOME -bed tir_orf_tir.loc.bed
# ORF with no flanks
bedtools getfasta -s -fo orf_no_tir.orf.fa -fi $GENOME -bed orf_noflank_total.bed
# Flanks with new ORF
bedtools getfasta -s -fo tir_unknownorf_tir.all.loc.fa -fi $GENOME -bed tir_uorf_tir_all.loc.bed
# 100BP regions
bedtools getfasta -s -fo tir_orf_tir.flank.fa -fi $GENOME -bed tir_orf_tir.flank.bed
bedtools getfasta -s -fo start.flank.fa -fi $GENOME -bed start.flank.bed
bedtools getfasta -s -fo end.flank.fa -fi $GENOME -bed end.flank.bed
# Syntenic grouping
bedtools getfasta -s -fo x38.synt.fa -fi $GENOME -bed synt38x.bed
bedtools getfasta -s -fo x969.synt.fa -fi $GENOME -bed synt969x.bed
bedtools getfasta -s -fo ux.synt.fa -fi $GENOME -bed syntUx.bed


sed -i "s/>/>${PREFIX}_/g" tir_orf_tir.orf.fa
sed -i "s/>/>${PREFIX}_/g"tir_orf_tir.loc.fa
sed -i "s/>/>${PREFIX}_/g" orf_no_tir.orf.fa
sed -i "s/>/>${PREFIX}_/g" tir_unknownorf_tir.all.loc.fa
sed -i "s/>/>${PREFIX}_/g" tir_orf_tir.flank.fa
sed -i "s/>/>${PREFIX}_/g" start.flank.fa
sed -i "s/>/>${PREFIX}_/g" end.flank.fa
sed -i "s/>/>${PREFIX}_/g" x38.synt.fa
sed -i "s/>/>${PREFIX}_/g" x969.synt.fa
sed -i "s/>/>${PREFIX}_/g" ux.synt.fa

# 10) SAVE ALL THE DESCRIPTION INFO
echo "${PREFIX},${tir_total},${tir_full},${tir_partial},${orf_total},${tir_flank_total},${tir_orf_tir_total},${orf_no_flank_total},${possorf_flank_total},${uorf_flank_total},${urof_flank_single_dir},${urof_flank_multi_dir},${nuorf_flank_total},${synt38total},${synt969total},${syntUtotal}" > atf4.summary


# 11) CREATE A PIDENT MATRIX FOR EACH TIR-AFT4-TIR SEQUENCE
conda activate emboss_env
if [ -e x38.synt.fa ]
then
	x38_pident=$(needle /mnt/iusers01/pb01/f99731hc/scratch/imperial/origin_atf4.fa x38.synt.fa -auto Y -stdout Y | grep Identity | cut -d"(" -f2 | sed 's/%.*//g')
else
	x38_pident=$(echo 0)
fi

if [ -e x969.synt.fa ]
then
	x969_pident=$(needle /mnt/iusers01/pb01/f99731hc/scratch/imperial/origin_atf4.fa x969.synt.fa -auto Y -stdout Y | grep Identity | cut -d"(" -f2 | sed 's/%.*//g')
else
	x969_pident=$(echo 0)
fi
if [ -e ux.synt.fa ]
then
	ux_pident=$(needle /mnt/iusers01/pb01/f99731hc/scratch/imperial/origin_atf4.fa ux.synt.fa -auto Y -stdout Y | grep Identity | cut -d"(" -f2 | sed 's/%.*//g')
else
	ux_pident=$(echo 0)
fi
echo "${PREFIX},${x38_pident},${x969_pident},${ux_pident}" > pident.summary
